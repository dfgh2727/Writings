// wrote_250304.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>


// 현 프로젝트에서 데디케이트 서버 사용 즉, 따로 서버를 두지 않기 때문에
// 동기화는 자기 책임이다.
// 
// 변수의 동기화
// 
// 먼저 서버와 클라이언트를 구분되게 만들자.
// 게임모드가 유효하지 않으면 클라이언트, 유효하다면 서버다.
// IsValid라는 함수로 확인할 수 있다.
// (굳이 C++로 nullptr인지 확인할 필요 없다.)
// (UObjectBase의 IsValidlower어쩌구로 this == nullptr인지 확인하고 있다.)
// 
// 멤버변수가 터지는 것은 this가 nullptr일 때다.
// 멤버변수등을 사용한다는 것은 this를 사용한다는 뜻이다. (this->멤버변수)
// this를 호출할 일이 없다면 this == nullptr이어도 터지지 않는다.
// 
// 캐릭터 블루프린트의 우측에 디테일 - 변수 - 리플리케이션에서 옵션이 Replaicated인지 확인하자.
// 
// 문제는 리플리케이트의 경우 서버에서 발생한 변화만 동기화 된다.
// 클라이언트가 발생시킨 변화는 반영(동기화)되지 않는다.
// 오로지 서버를 통해서만 변경된다.
// 즉, 서버를 기반으로 돌아간다.
// 
// 
// C++로 동기화시킬 경우... (꽤나 복잡하다.)
// UPROPERTY()에 Replicated를 적자.
// 동기화 시키고 싶은 변수가 있다면, 그 변수를 가진 Actor를 Replaicated로 설정해야 한다.
// 그리고 함수를 만든다.
// void GetLifetimeReplicatedProps()
// 리플리케이트 변수는 위 함수를 호출하기 때문에 없으면 에러가 발생한다.
// #include "Net/UnrealNetwork.h"
// 
// 그러나 여전히 클라이언트의 변화는 반영되지 않는다.
// 클라의 변수 변화를 동기화시키고 싶다면?
// RPC를 사용해야 한다.
// RPC (Unreal)
// : 네트워크 환경에서 어떤 함수가 실행되었을 때 
//   다른 접속자들도 그 함수를 호출하거나 특정 규칙에 따라 호출하게 만든다.
// 
// UFUNCTION(BlueprintCallable, Reliable, NetMulticast) 
// void 동기화를원하는함수();
// 위와 같이 UFUNCTION의 인자에 Reliable이라 입력하면 RPC를 사용한다.
// 그리고 옵션에 따라 네트워크 접속자들의 함수 실행 범위를 설정할 수 있다.
// NetMulticast : 서버에 접속한 모두가 함수를 실행하게 만든다.
// Server : 서버와 함수를 호출한 클라이언트만 실행한다. 
//          리플리케이트는 서버 기반이기 때문에 변수같은 경우 서버만 반영되도 모두가 반영 가능하다.
// Client : 서버에서 호출하고 클라이언트에서 실행한다.
// 
//
// RPC를 구현해보자.
// 실행할 함수의 Implementation을 구현해야 한다.
// (함수 원본은 구현할 필요 없다. 에러가 뜰 수도 있지만 무시하자.)
// 
// 실행시킬 함수에 중단점을 걸고 몇번 실행되는지 확인해보자.
// 
// 
// 
//

// 
// 
// 
// 
// 
