// wrote_250304.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>


// 현 프로젝트에서 데디케이트 서버 사용 즉, 따로 서버를 두지 않기 때문에
// 동기화는 자기 책임이다.
// 
// 변수의 동기화
// 
// 먼저 서버와 클라이언트를 구분되게 만들자.
// 게임모드가 유효하지 않으면 클라이언트, 유효하다면 서버다.
// IsValid라는 함수로 확인할 수 있다.
// (굳이 C++로 nullptr인지 확인할 필요 없다.)
// (UObjectBase의 IsValidlower어쩌구로 this == nullptr인지 확인하고 있다.)
// 
// 멤버변수가 터지는 것은 this가 nullptr일 때다.
// 멤버변수등을 사용한다는 것은 this를 사용한다는 뜻이다. (this->멤버변수)
// this를 호출할 일이 없다면 this == nullptr이어도 터지지 않는다.
// 
// 캐릭터 블루프린트의 우측에 디테일 - 변수 - 리플리케이션에서 옵션이 Replaicated인지 확인하자.
// 
// 문제는 리플리케이트의 경우 서버에서 발생한 변화만 동기화 된다.
// 클라이언트가 발생시킨 변화는 반영(동기화)되지 않는다.
// 오로지 서버를 통해서만 변경된다.
// 즉, 서버를 기반으로 돌아간다.
// 
// 
// C++로 동기화시킬 경우... (꽤나 복잡하다.)
// UPROPERTY()에 Replicated를 적자.
// 동기화 시키고 싶은 변수가 있다면, 그 변수를 가진 Actor를 Replaicated로 설정해야 한다.
// 그리고 함수를 만든다.
// void GetLifetimeReplicatedProps()
// 리플리케이트 변수는 위 함수를 호출하기 때문에 없으면 에러가 발생한다.
// 아래의 헤더도 추가하자.
// #include "Net/UnrealNetwork.h"
// 
// 그러나 여전히 클라이언트의 변화는 반영되지 않는다.
// 클라의 변수 변화를 동기화시키고 싶다면?
// RPC를 사용해야 한다.
// RPC (Unreal)
// : 네트워크 환경에서 어떤 함수가 실행되었을 때 
//   다른 접속자들도 그 함수를 호출하거나 특정 규칙에 따라 호출하게 만든다.
// 
// UFUNCTION(BlueprintCallable, Reliable, NetMulticast) 
// void 동기화를원하는함수();
// 위와 같이 UFUNCTION의 인자에 Reliable이라 입력하면 RPC를 사용한다.
// 그리고 옵션에 따라 네트워크 접속자들의 함수 실행 범위를 설정할 수 있다.
// 실행 범위는 호출자가 서버인지 클라인지에 따라 달라진다.
//  
// 호출 주체              서버                         클라이언트
// NetMulticast : 서버에 접속한 모두 실행         호출한 클라이언트만 실행
// Server :       서버만 실행                     서버에서만 실행(변수 반영 가능)          
// Client : 서버에서 호출하고 클라이언트에서 실행한다.
// 
// RPC를 구현해보자.
// 실행할 함수의 Implementation을 구현해야 한다.
// (함수 원본은 구현할 필요 없다. 에러가 뜰 수도 있지만 무시하자.)
// 
// 실행시킬 함수에 중단점을 걸고 몇번 실행되는지 확인해보자.


// 스폰 동기화 
// 
// 액터를 만들었는데 리필리케이트되지 않으면 한쪽만 생성된다.
// 혹은 설정하더라도 완벽하게 동기화 되어있지 않다.
// 선생님의 추천은 C++에 기본 옵션으로 만들어 놓는 것.
// 
// 함수가 총 몇번 실행될까?
// 함수를 호출하는 대상 x 클라이언트와 서버 수
// 위와 같이 생각해야 한다.
// 그런데 통상적으로 아이템 같은 경우 하나를 만들고 그것을 공유하길 원한다.
// 
// 서버만 Data setting을 한다. 클라이언트는 안 한다.
// 서버에서 먼저 data를 기반으로 만들어지면 그 후에 클라이언트에서 만들어진다.
// 그렇다면 RPC 함수를 대량생산해야 될까? 
// 아니다. 아이템이 직접 동기화하게 만들자.
// 
// SpawnActorDeffered()
// BeginPlay가 언제 실행될까?
// SpawnActor()는 바로 world에 편입되어 BeginPlay()가 실행되므로 동기화가 어렵다.
// SpawnActorDeffered()는 actor 생성까지만 실행한다. 
// world 편입과 BeginPlay()는 실행하지 않는다.
// 
// FinishSpawning()
// 생성을 완료하고 world에 편입시키는 함수.
// Deffered함수를 사용했다면 위 함수를 사용하는 것이 좋다.
// 
// 결론적 동기화를 위해서 다음과 같이 진행한다.
// SpawnActorDeffered()으로 Actor 생성 -> 데이터 셋팅 (동기화) -> FinishSpawning()으로 world 편입
// 
// 게임중 한명이 아이템과 충돌했다면, 각 접속자마다 충돌이 발생한다.
// 접속자가 n명이라면 충돌 함수가 n번 실행된다.
//
// 네트워크를 다룰 때 함수가 몇번 실행되는지 잘 생각해야 한다.
//
