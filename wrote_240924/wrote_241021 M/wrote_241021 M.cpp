// wrote_241021 M.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
   
}

//API란 무엇인가? (ppt)
//:Application Programming Interface
// 
// window API
// window를 사용하는데 도움이 되는 함수 집합
// 
// 
// 오픈소스는 직접 빌드 가능한 
// API는 결과물 중심으로 공개, 배포된다.
// (요즘 게임들은 엔진 내부 코드를 공개하지 않는다.
//  그래도 궁금한가? 언리얼 코드를 봐라. 유저친화적이지 않지만.)
// 
// 결과 파일들은 아래 4가지.
// .exe, .pdb, .lib, .dll (.h까지 공개하는 경우도 있다.)
// (오픈 소스의 경우 프로젝트를 빌드하면 자연스럽게 결과 파일 생성이 가능)
// 
// .exe  OS에서 동작할 수 있는 실행파일
//      :코드영역을 구성하는 내용과 메모리 구성하는 함수들
//       
// .lib  : .exe 에서 OS에서 실행되는 기능만 제외된 파일
//       cpp 내용이 다 빌드되어 완전히 2진으로 이루어진 상태, 
//       헤더가 필요하다.
//       
//       헤더를 넣어서 빌드하면, 선언만 있고 구현(cpp)이 없다고 뜬다. (확인할 수 없는 외부 참조)
// 
// .exe는 lib를 가진 상태로 나온 결과물, 따라서 lib를 삭제해도 .exe는 실행된다. 
// 즉, 게임 플레이어 입장에서 lib는 필요 없는 파일이다.
// 
// 실제 클라이언트의 경우 엔진의 내용을 알 수 없다.
// (언리얼 같이 오픈소스 엔진이 아닌 경우 제외)
//
// sdk, 개발자용 API? 
// 
// .dll  필요할 때만 연결할 수 있는 빌드 결과 파일
//      : .exe 파일 내부의 함수를 통해 사용해야 실행된다.
//       OS에 로드해서 사용한다. 즉,.exe에 일일히 포함되어야 하는 .lib와 달리 
//       하나만 존재해도 OS를 통해 여러 프로그램에 사용 가능. 
//       (이 때문에 예전에는 lib보다 dll이 선호되었다.)
// 
// .pdb, .idb (기호파일)
//      : 디버깅용 네임맹글링 정보를 기록해 놓은 파일
//        (현재 교육 과정에선 큰 의미가 없다.)
//        번역 과정을 기록해 놓은 파일...lib 보다 용량이 훨씬 크다.
//       


//핵심 클래스는? 어떻게 짰는가? 왜 그렇게 짰는가?


//080_WindowProjectStart
// 
// 처음 보는 코드라도 파악할 줄 알아야 한다.  
// 대략적으로 코드를 읽어보자.
// 
// define의 원리? 복붙.
// ##은 지워진다. 구시대 문법...구분해야 할 값에서 매크로 함수의 인자에서 분리
// 
// 핸들
// 커널영역...window(OS)가 점유하고 있는 RAM과 CPU 영역
// 이 영역에 대해서 외부에 알리고 싶지 않다.
// 그러나 사용자가 기능을 사용해야 하므로 window가 키(포인터)를 준다.
// 이 키를 통해서 window가 사용자를 인식한다.
// 함수 인자로 핸들이 들어간다.
// 
// HINSTANCE
// 가장 중요한 핸들
// 윈도우가 인식하는 내 프로그램(포인터)의 자체 핸들
// 


//082_MainParameter
//
// 모든 프로그램에는 진입점이 있다.
// 진입점에는 언제나 2개의 인자를 배치할 수 있다.
// 
int main(int _Count, char** _MainParameter)
{

}
// cmd에서 프로그램명 뒤에 메인 파라미터를 입력하면 
// 해당하는 기능 실행
// (cmd 창에서 입력하는 git(.exe) clone의 경우 'clone'이 메인 파라미터, 입력후 복붙 기능 실행)
// 
// hPrevInstance 이 자리에 런쳐가 들어가는 경우가 있다.(내 프로그램을 켜는 프로그램)

// (다시 window로 돌아와서...)
// 
// UNREFERENCED_PARAMETER
// 경고 때문에 있는 문구. 없는거나 마찬가지.
// 어떤 메모리 영역에 ()안의 내용은 사용한 걸로 인식한다.
// 
// 
// LoadStringW
// 
// 윈도우의 기본 리소스 방식을 보면...
// 
// .exe파일이 존재할 폴더에 .rc파일이 같이 존재하면
// 윈도우가 자동으로 로드 해준다.
// (아이콘도 이렇게 바꿀 수 있다! 야호!)
// 
// stringtable에 있는 문자열(값) 입력하면 그에 해당하는 리소스를 사용할 수 있다.
// (OS가 리소스를 로드해 놓은 상황)

//083_System
// 
// 그닥 중요한 건 아니다.
//

//(다시 window로)
//
// MyRegisterClass (중요하다)
// :window class를 등록하는 함수 (window class는 윈도우창의 형식)
// 
// 게임을 하려면 윈도우 창이 필요하다.
// 윈도우 창에서 쓰는 아이콘이나 커서 기타등등을 윈도우에 알려줘야 한다.
// 창의 스타일을 등록시키는 함수는 인자가 많기 때문에 
// 구조체를 만들어서 넣어주는 스타일로 만든다.
// 
// 건축허가서를 생각하면 된다.
// 건축허가서 내용은 뭐... 다 기억할 필요 없다.
// (menu는 null하면 메뉴창 사라진다.
//  요즘은 window 커서를 null로 만들고 다렉으로 만드는 추세다.)
// 단, 무슨 이름으로 등록을 했는지는 알아야 한다.
// 
// 
// WS_OVERLAPPEDWINDOW
// 비트 단위 연산자를 사용해서 메뉴를 만드는 것
// window가 기본적으로 제공하는 것으로는 C스타일 즉, 절차지향적으로 짜여있다.
// C++ 에선 객체지향 즉, 클래스로 만들어서 구현할 것이다.
// 
 

//084_strings
// 
// 문자열...멀티와 와이드로 나뉜다. 

char aPtr[10] = "aaa";
wchar_t WPtr[10] = L"aaa";

//함수명 앞이나 끝에 w를 붙여서 wchar_t 문자열 함수라는 것을 표현한다.
//어떤 함수에 A나 
//
