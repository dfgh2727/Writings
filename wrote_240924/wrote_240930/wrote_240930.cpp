// wrote_240930.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

//값을 명시하는 순간 구현이 된다.
//실체(구현) = 메모리화
class monster
{
public:
	int a = 0; //구현인가? 아니다! 선언이다.
};

monster MyMonster; //이때 itn a 가 구현된다.

//클래스는 기본적으로 선언이다.
//클래스는 동시에 선언 불가능하다. (같은 이름)
class Player {};
class Player {};  //이런게 불가능하다.

//전역 함수의 선언... 한 파일 내에서 중복 가능? 그렇다.

// 
// 자료형의 구분
// 1. 기본자료형... 재정의 불가능 
// 2. 사용자 정의 자료형

int main()
{
	monster New; //구현
	int a; //선언
}
//선언만 하고 사용을 안 하면 컴파일러가 의미 없다고 생각한다.
//자료형 안에 어떤 기능이 있다면 그걸 구현해줘야 한다.
// 
//한 파일 (=하나의 cpp) 내에서 선언 중복이 가능한 문법이 있다.
//함수... 전역함수와 멤버함수(클래스)
//자료형, 객체, 전역함수의 선언과 구현에 대한 이해
//

class Battle
{
public:
	void Test() //멤버함수의 구현이지 클래스의 구현이 아니다.
	{

	}
};

//하나의 파일 안에서 같은 이름은 선언 불가능하다.

//확장자 의미 없어...h와 cpp라도 다 텍스트 파일로 인식한다.
//
//구현은 중복 불가능하다.

//언리얼 스탠다드.... 클래스명 앞에 U를 붙인다.
// class UFightunit {};

//****코더와 아키텍처의 차이? 프로젝트 설정을 할 줄 알아야 한다.****

//헤어 안에는 최대한 헤더가 없을수록 좋다. 순환 참조 때문에.
//#include ""  내가 만든 파일,
//#include <>  외부 파일 (VC++ 디렉터리의 포함 디렉터리를 확인해보자 )
// 
// 라이브러리...dll, lib 등의 위치. 
// (진짜 실행 파일은 아니지만 다른 프로젝트에서 사용하기 위해 만든 코드들의 위치)
//디렉터리들 안 만질거다. 에러난다.

//다시 돌아와서... 헤더 순환참조가 뭐지?
class Parent
{
public:
	Child Child0;  //(부모가 자식을 알면 안 된다.)
};

class Child: public Parent
{

};
//이것이 순환참조.
//서클형이 가장 위험하다.
//#include를 최소화하자.
// 
//(그러나 상속관계 만큼은 #include를 피할 수 없다.
// 자식의 크기를 알려면 부모의 크기를 알아야 한다.)
// 포인터는 상관없다. 무조건 크기가 8바이트니까.
// 
// 헤더(.h)에서 함수를 구현하지 않음.
// 어떤 클래스의 함수를 사용하려면 호출을 위해 헤더가 필요하기 때문에.
// 잘못하면 순환구조가 만들어진다.
// 반드시 헤더는 선언만!

//순환 방지를 위해...
//상위개념(좀 더 근본적인)은 항상 위에. ('중력'이 '플레이어'를 알아야 하나? 아니다.)
// 
//


//전방선언?
class Weapon Axe;
// 마치 extern 처럼 있을거라고 선언해주는 것.
// 전방선언은 중복 가능하다.
// 



//virtual
// 
//
//