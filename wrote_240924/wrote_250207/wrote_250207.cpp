// wrote_250207.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>


// (...어제에 이어서 GM2DX에 네트워크 기능 구현)
// 패킷을 위주로 개발할 예정.
// 
// StartUp은 한번만 실행하면 되니까
// if(true == NetInit)
// {
//     StartUp을 이미 실행한 상태면 다시 실행 안 함
// }

// crtl + Alt + P ->실행시킨 프로그램에 한해서 연결을 하면 동시에 디버깅이 가능하다. 

// 토큰, 일종의 권한이다. 
// 클라와 연결된 서버 둘만이 알고 있는 값이다. 사용자를 식별하는데 사용한다.
// 연결이 끊어지면 토큰은 의미가 없어진다. 재접속할 때 마다 새로운 토큰을 발급한다.
// 특히 UDP 같은 경우 소켓이 없기 때문에 토큰으로 사용자를 구분한다.
// 모바일의 경우 기지국이 계속 바뀌므로 토큰으로 재접속자를 확인한다.
// 동일한 토큰을 가진 유저가 2명 이상이면 튕기기도 한다.

// 제이슨(JSON), XML
// string을 parsing으로 파악한다.
// 직접 눈으로 봐도 어떤 데이터인지 파악하기 쉬운 언어다.
// 구글은 XML을 채택했다.
// 
// 그러나 게임의 경우 위와 같은 언어는 쓰지 않는다.
// 패킷 용량이 매우 크기 때문에 비효율적이다.

 
// 서버는 네이티브를 선호하는 경우가 많다.  
// 그리고 C++ 스탠다드가 아닌 C스탠다드 스타일을 사용하는 경우가 많다. 
// 속력에 민감하기 때문이다.
// (따라서 shared_ptr를 잘 안 쓴다)
// 
// 언리얼의 프로토콜은 너무 무겁다.
// 따라서 게임사가 언리얼이 제공하는 서버 기능을 그대로 쓰는 일은 거의 없다.
// 
// 현재 GM2DX에 적용하는 서버는 코옵 수준이기 때문에 shared_ptr을 사용한다.
// 서버에 비해 프로토콜이 무거운 상태다.
 
// recv()는 서버와 클라 공통이다. 따라서 다르게 만들 필요가 없다.
// UEngineNet에 위치.
// 파일을 저장하는 것과 패킷을 만드는 것은 유사하다.
// 따라서 모든 RecvThread에는 serializer가 존재한다.

// 서버는 절대로 컴파일러의 경고를 무시하면 안 된다.
// 바이트 수에 조금이라도 오차가 생기면 문제가 된다.

// 클라가 자신을 제외한 다른 클라들의 토큰값을 알고 있다.
// 
// 패킷에 프로토콜 자체를 담으면 가상함수 테이블까지 보내진다.(virtual)
// serializer로 데이터를 담아서 패킷을 전송하자. 
// _Protocol->serializer

// 이번 프로젝트의 프로토콜과 인터페이스:
// 
// SessionToken = 0은 서버다. 
// 
// StartProtocol.SetSessionToken(Server->SessionTokenCreator++);
// StartProtocol.SetPacketType(EEnginePacketType::UsserAccessPacket)
// StartProtocol.Serialize(Ser);
// 먼저 서버가 접속자에게 세션토큰을 전송한다.
// 전송 후 클라이언트가 토큰을 받고 패킷을 보내면 서버는 클라가 준비가 됐음을 확인한다.
// 
// UsserAccessPacket = -2
// 패킷 타입이 음수인 경우는 엔진만 사용한다.
// 유저가 사용 불가능한(컨텐츠에서 사용 불가능한) 패킷타입이다.
// 
// 여러곳에서 동기화 가능하게 atomic을 사용해서 토큰을 만든다.
// 
// 서버는 보통 패킷 자동화 시스템이 있지만
// 우리는 없으니(...) 직접 패킷 타입을 지정해야 한다.
//
// recv를 받았다는 것은 serializer에 데이터가 들어왔다는 뜻.
// 이 때 패킷타입만 확인하고 싶으니 (읽지말고, ReadOffSet의 변화 없이)
// SeekData()라는 함수를 만든다.
// 
// int TempPacketType = Ser.SeekData<int>();
// 
// if( 0 > TempPacketType)
// {
// 
//   continue;
// }
//  
// 
// bool IsNetStart()
// {
//   
// }
// 이제 앞의 과정들을 거쳐서 SessionToken != -1이면 준비가 된거다.
// 
// 패킷의 크기는 Serialize과정이 다 끝나야 알 수 있다.
// StartProtocol.SerializePacket(Ser);

//    A 컴퓨터              B 컴퓨터
//  _____________         _____________
// |    [플]     |  ~~~  |    ...[플]  |
// |_____________|       |_____________|
// 
// 플레이어가 움직인다 -> 클라이언트가 처리 (패킷 타입, 패킷 크기, 세션 토큰, 오브젝트 토큰...) -> 
// 이때 코옵중인 A컴퓨터와 B컴퓨터 모두에서 플레이어를 움직이려면 
// 플레이어를 확인하는 오브젝트 토큰이 필요하다.
// 
// 동기화 될 필요가 없는 object들은 ObjectToken이 필요없다. 
// ObjectToken이 -1이면 동기화 될 필요없는 오브젝트다. (배경의 나무라던가...)
// UNetObject  
//


