// wrote_241028 M.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
    std::cout << "Hello World!\n";
}

//엔진을 사용할 떄 기능을 직접 만들지 말고 엔진이 제공하는 기능을 써야한다.
//
// 1. 컨텐츠를 많이 사용한다.
// 2. 엔진이 업데이트 되면 만들어 둔게 무너진다. 
// 
// 직접 만들어야 한다면...OS인지 std인지 따져야 한다.
// 1. 기본적으로 하드웨어에 관련된 것은 대부분 OS
// 2. 문법적인 측면에서 접근하는 경우는 std
// 
// 엔진을 랩핑하는 대표적인 방법
// (EngineWindow가 우리 엔진의 대표적인 랩핑 클래스다.)
// WinAPI 기능을 공개하는 경우는 없다.
// 
//

//(API)
// 
// 필수 라이브러리 함수들을 native function이라고 한다.
// 
// window의 타이틀을 바꾸는 함수...있다.
// SetWindowTectA();
// 당연히 인자는 핸들(HWND)이다.
// 
// RAM에 위치한 OS와 나의 프로그램...
// 윈도우창 메모리는 OS에 생기고 그에 대한 포인터(핸들)가 내 프로그램에 생긴다.
// 
// ContentsCore에서 SetWindowTitle에 접근하게 만들었다. 
// 
// Player.cpp
// 입력...키보드를 관리하는 OS를 통해서 실행
// 윈도우가 제공하는 기본 입력함수를 사용
// 
// 입력 버퍼는 윈도우가 알아서 처리하기 때문에 
// 입력이 있을 때만 0이 아닌 수를 처리한다.
// GetAsyncKeyState()
// 
// (키의 압력은 무시하자. 오래 눌렀다는 체크 가능)
// 
// EnginePlatform
// (Input)
// class UEngineInput 생성자를 private로 만들었다.
// 

//Singleton
// 디자인 패턴 (관리패턴, 생성패턴, ...)
// 
// 싱글톤, 단 하나의 instance를 만드는 패턴. (by 갱오브포)
// 객체를 프로그램 통틀어서 단 1개만 만든다.
// 보통 static과 함께 쓴다.
// 클래스 자기 자신이 만들어서 외부에 공개한다.
// 
// 크게 포인터형과 값형으로 나눈다.
// 포인터형의 장점, 지울 수 있다. 한 쌍의 삭제함수를 무조건 만들어야 한다.
// but 반드시 어디선가 호출해야 한다.
// 값형으로 진행한다.
// 
// 
// 
