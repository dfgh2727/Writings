// wrote_241108.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
}

// (API)
// 
// 2DCollision
// 
// vector<U2DCollision> Result
// 충돌 상대가 담겨있는 vector
// 
// bool U2DCollision::Collision ()
// 어떤 그룹과 충돌한다.
// 그리고 모든 충돌체를 한 곳에 모아 놓은곳이 level
// 
// 
// 충돌 타입을 정하자.
// 
// 사물 모양 그대로 충돌하는...메쉬충돌
// 가장 정밀하지만 부하가 심하다.
// 어떤 사물을 이루는 도형들과 충돌상대를 이루는 도형들의 충돌을 모두 확인한다.
// 충돌 당시만 아니라 항시 충돌여부를 체크하기 때문에...
// 
// 보통은 가장 가벼운 원 충돌로 한다.
// (회전하는 사각형도 느리다. 원충돌의 80배
//  일반 사각형은 원의 1.5배.)
// 
// 차원값이 작아질수록 충돌 계산이 빠르다.
// 그리고 대부분의 온라인 게임은 2차원 충돌을 사용한다.
// 
// 클라이언트에만 영향을 주는 충돌은 정밀한 충돌을 사용해도 된다.
// 코옵 게임(100인 이하)에 가까울수록 정밀한 퉁돌을 쓴다. 온라인 게임은 정밀한 충돌을 안 쓴다.
// 코옵 게임에 가까울수록 핵(메쉬 정보 수정)이 난무한다. (충돌을 서버가 아닌 클라이언트가 담당하기 때문에.)
// 
 
// FTransform 은 위치(Location)와 크기(Scale)를 가지고 있다.
// 즉 도형이 될 수 있다.
// 
// ECollisionType
// SetCollisionType()
// 충돌 타입을 설정해주자.
// 
// FTransform::RectToRect(FTransform)
// 사각형과 사각형의 충돌
// (충돌 공식은 마지막에 추가)
// 
// 나의 충돌 타입(ThisType = ThisCollision)과 상대의 충돌타입(DestCollision)
// 
// 근데 충돌 타입이 많아지면...
// 서로 타입을 바꿔서(Swtich문) 충돌을 체크한다? 코드가 많이 복잡해진다.
// 
// **************** Tip ********************
// 
// 인자와 리턴값이 같은 형인 함수라면?
// Functional을 쓰거나 함수 포인터를 쓰자.
// 
// 그렇게 함수를 만들었는데...프로그램이 시작될때 반드시 호출되어야 한다.
// 클래스를 만들어서 생성자에 넣고 전역으로 설정하자. (데이터 영역에 존재)
// 데이터 영역이 초기화 될때 초기화를 자동으로 실행할 수 있다.
// 
// 그리고 전역에서 private 설정했으니 friend 설정해서 사용.
// 
// ******************************************
// 
// ...
// Type과 FTransform만 입력하면 충돌 사용이 가능하다.
// 
// 
// 결국 충돌체 자체가 아닌 actor에 관심이 있으니 GetActor로 받아준다.
if (/*nullptr != _Result*/ && true == Result)     //포인터방식에서 참조(Ref)로 바꿔서 null을 확인하지 않는다.
{
    _Result->push_back(DestCollision->GetActor());
}
//그리고 Collision을 가진 부모(AActor)에서 불러온다.
//     
// collisionAll은 여러 대상과 충돌할 수 있으니 vector로 처리했다. 


// static 선언했다면 반드시 구현!

// float 절반값이 나오는 함수를 만들었다. 
// hX();

//사각형 충돌의 규칙
// 
// (U2DCollision)
// Dest의 Right가 This의 Left보다 작다면 충돌 불가.
// (Dest의 Right와 This의 Left가 같다면 둘이 닿았다, 충돌판정)
// Dest의 Bottom이 This의 Top 보다 크다면 충돌 불가.
// .
// .
// .
// 등등 위와 같은 조건들을 모두 통과했다면 충돌판정.
// 
// 충돌체의 Release
// Renderer와 관리 구조가 같다.
// 다른 component와 달리 충돌과 Renderer는 엔진이 따로 관리한다.
// 
// destroy를 AActor에 위치시킨다.
// ...공격해서 몬스터가 destroy 가능하게 만들었다.

// 원 충돌 
// 
// FVector2D Len = 나의 중심과 상대 중심 사이의 거리 
// 
// FTransform을 원으로 봤을때 반지름은 X의 절반크기를 반지름으로 본다.
// 
// 두 원의 반지름의 합이 벡터의 길이보다 크다면 충돌판정.
// 


 

