// wrote_241004.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
    std::cout << "Hello World!\n";
}

// **정정**
// 리터럴 초기화가 아니라...

// ****** 이 필기는 054_FileO와 같이 봐야한다. ******

//앞으로 파일 돤련된 것들은 Uenginefile에 ㅣㅇㅆ을것
// 파일 저장할 때는 void 포인터를 쓰자. 
// 
// w예외처리
// 
// 
//배열명 상수만 가능하다. 크기가 정해져야 하니까.
//
// 랩핑
// 
// 선언과 구현이 분리된건 inline처리 할 수 없다.
// inline 사용 기준을 확인해보자. 


// 파일 읽는거? OS가 지원해줘야 가능하다.
// 파일명 넣는 곳은 보통 경로 자체를 넣을 수 있다.
// 
// (UEngine. NewFile  클래스이자 지역변수)
// 
// void UEngineFile::Close();
// 만약 닫지 않는다면 다른 곳에서 사용할 수 없겠지. (오픈하는 것도 잊지 말기.)
// 보통 파일 혹은 플랫폼의 기능들은 언제나 한쌍이다.
// 시작한다, 사용한다 - 끝낸다.
// 
// 방어코드는 사실 끝이 없단다. 
// 서버는 if문이 한가득이다. 클라는 뭐...
// 
// 파일 입출력? 캐릭터 저장하고 불러낼려고 배운거다
// 분리된 파일은 어떻게 하지?
// 
//

//소멸자
// 무조건 클래스 이름과 같다. 
// ~클래스명 () {}
// 소멸자는 자신을 포함하고 있는 메모리 영역이 파괴될 때 한번 호출되는 함수
// 소멸자는 직접 호출하지 않는다. 암묵적 룰이다. 혼돈하기 쉽다.

void UnrealFile::Close()
{

}

//포인터를 인수로 받고 const가 안 붙어있다? 포인터가 가르키는 값이 바뀔 수 있다.

void UEngineFile ::

//char[] Arr0;
//char[] Arr01;
//Arr0 + Ar102; 이렇게는 안 된다.
//문자열 바로 합치기 불가능.,



// 기술?
// 플랫폼 기능이 우선이다.
// 구글 연동, 스팀 연동, 현질 관련된 것들...