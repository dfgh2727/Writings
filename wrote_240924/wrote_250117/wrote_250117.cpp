// wrote_250117.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//


// (쓰레드)
// 윈도우에서 제공하는 기능을 통해 스레드에 이름을 부여할 수 있다.
// Job System
// sleep() 
// 일정시간 이 스레드를 재운다. 단위는 mS.
// 언제 깨울 수 있을까?
// Window에서 Event와 WaitForSingleObject라는 함수를 제공한다.
// 
// IOCP는 최종병기? 윈도우에서 쓰레드를 통합관리할 시 무조건 사용하게 된다.
// 
// SetThreadDescription()
// std::thread()에서 호출할시 어떤 스택안에 있는 코드라도 그 스택과 완전히 메모리가 다른 영역이다.
// 
// 쓰레드 점유...무슨 의미일까.
// 프로그램이 명령을 통해 캐쉬를 차지한다.
// 이 명령을 sleep()을 통해 정지시킬 수 있다.
// c++ 기초함수를 통해 쓰레드를 조절할 수 없다. 무조건 OS의 지원을 받는 함수를 사용해야 한다.
// 
// (...프로젝트로 돌아와서)
// 엔진에 있어서
// EngineBase, OS의 영향을 받지 않는 것이 좋다.
// EnginePlatform 부터 OS의 영향을 받는다.
// 
// UEngineThread
// 언리얼 방식은 아니다. 언리얼에서 native thread를 사용하려면 run...어쩌구를 사용해야 한다.
// 
// 게임중에 검은 화면...그 때 Core가 동작한다. (레벨준비, 어쩌구...)
// 이 시간이 매우 짧기 때문에 로딩화면은 필요하지 않다.
// 그러나 일부러 로딩화면을 만들기도 한다.
// 보통 로딩 화면이 뜨는 시점에 Graphic은 준비되어 있지 않다. 
// 즉 로딩화면의 이미지는 따로 만들어야 한다. 쓰레드를 이용하자.
// 
// thread안에서 사용하는 숫자는 간단하더라도 보호해주는 것이 좋다.
// 동시에 접근하는 문제가 발생할 수 있기 때문에.
// bool값인 loadingEnd를 atomic으로 보호.
// 
// 한번 로드한 이미지를 언로드하지 않는다...
// 별로 좋지 않다.
// 
// if(true == LoadingEnd)
// {
//   UEngineCore::CreateLevel(...)
// }
// loadingEnd가 끝나면 level이 만들어지게 한다.
// 
// 그러나 무조건 로딩을 사용해야 한다는 것은 아니다.
// 어쨌든 thread를 사용하면 시간이 걸리니까.
// thread...delta타임 사용할 수 없다. 
// main thread와 시간을 동기화 시켜야 하는데 그러면 thread를 사용하는 의미가 없다.
// 
// joinable() 
// bool값으로 끝난 쓰레드인지 아닌지 확인할 수 있다.
// UEngineThread::Start()
// 쓰레드 start 여부를 알린다.
// 
// SetThreadDescription()
// 쓰레드 이름을 정하는 것은 그 쓰레드 내에서만 가능하다.
// ...그러나 사용하기 힘든 구조니 원하는 위치에서 명명(UEngineThread::Start()),
// 그리고 그 함수의 내용을 쓰레드가 실행한다.
// 
// 여차저차, 쓰레드를 사용하면 시간이 더 걸린다.
// (pushback...thread가 실행해야 하는 단계가 매우 많다.
//  자료구조에 사용하기엔 매우 비효율적이다. 게다가 동시 접근할시...무슨 상황이 발생할 수 없다.
//  게다가 메모리 용량이 크기 때문에 atomic으로 보호할 수도 없다. atomic으로 기본 자료형만 보호할 수 있다.
//  그러나 CRITICAL SECTION라면...)

// 109_Thread_002
// 
// 쓰레드의 장점?
// Linux, window 구분 안하고 thread 사용 가능하다.
// functional을 사용할 수 있다. 쓰레드에 넣어주기 위한 함수를 따로 만들 필요가 없다.
// window등에 존재하는 event등이 없어서 join기능 등으로 쓰레드의 종료 웨이팅을 쉽게할 수 있다.
// 
// 임계영역은 기본 자료형 아니면 보호할 수 없나? 아니다.
// 
// CRITICAL SECTION  = 임계영역을 보호한다.
// critical section, 임계영역 = 다수의 쓰레드가 접근하는 메모리 영역
// 
// InitializerCriticalSection(&CS) 
// 
// CRITICAL SECTION을 비유할때 보통 화장실에 비유한다;;
// 쓰레드는 기다리는 사람들;;
// EnterCriticalSection(&CS) 임계영역을 획득한다.(화장실 문을 잠근다.)
// LeaveCriticalSection(&CS) 임계영역을 반환한다. 그 다음 임의의 쓰레드가 임계영역을 획득.(화장실 문을 연다.)
// 이렇게 쓰레드가 메모리에 동시에 접근하는 것을 막는다.
// 
// 그러나 안 걸 수 있다면 최대한 걸지 않는게 좋다.
// (그렇다고 무조건 느려지는 것은 아니다.)
// 다른 방식? 메모리를 분할하고 이후에 동기화 하는 방법이 있다.
// (std::list<int> TestList을
// 
//  아래와 같이 분할하고
//  std::list<int> TestList1
//  std::list<int> TestList2
//  std::list<int> TestList3  
//  나중에 동기화 시킨다.)
// 
// Mutex , 내부에서 CS를 만든다. 
// lock(), unlock()을 이용해 사용.
// 그러나 unlock()하지 않으면 내부에 쓰레드들이 갇힌다;;
// 따라서 LockGuard라는 클래스를 만들어서 생성자에 lock(),  소멸자에 unlock()을 만들어서 사용하는 경우가 있다.
// 함수가 종료되는 시점에서 unlock시키고 싶다면 지역변수로 선언하자.
// 
// new...c++자체에서 잘 막아서 스레드를 사용해도 터지지 않는다.


// 임계영역
// 스택을 제외하고 각 쓰레드들이 공유하는 메모리 영역에 존재해야 하며 값이 수정 가능해야 한다.(힙, 데이터 영역)
// 즉, 코드 영역은 영향이 거의 없다는 뜻. const는 임계영역이 될 수 없다.
// 
// 쓰레드를 가장 효율적으로 사용하는 방법
// 1) 어떤 일이 있다면 그 일을 분할해서 최대한 많은 쓰레드에 맡겨야 한다.
// 2) 쓰레드를 사용하지 않으면 재우고 사용할때만 깨운다.
// 
// Context Switching
// 프로그램이 n개, CPU가 하나라면 
// 캐쉬에 연산을 위한 메모리를 저장했다가 CPU로 넘겨서 연산이 끝나고 다음 프로그램이 진입할 때 기존의 메모리가 
// 내려가고 올라가는 현상. 캐쉬 적중률과는 무관하다.
// 만약 while문 안에서 무언가가 실행된다면 지속적인 요청이 올것이다. 이것을 CPU가 점유당했다고 하고 
// while문을 사용한 쓰레드를 비지쓰레드라고 한다.
// context switching이 빠르게 이루어져야 많은 연산을 적은 시간 안에 처리할 수 있다.
// 
// 제한된 자원(CPU와 캐쉬)안에서 얼마나 효율적으로 일을 맡겨서 어떻게 일을 처리하게 만드느냐를
// 알고리즘적으로 스케쥴링이라 한다. 대표적으로 RR라운드 로빈방식이 있다.
// 
// 한가한 쓰레드에 일을 맡기면 효율적이지만...쓰레드가 일이 끝난것을 알 수 없다.
// 그래서 Window에서 IOCP라는 시스템을 만들었다.
// 
// EngineWorkThreadPool (언리얼에서 BackGroundWorker등으로 불린다.)
// 쓰레드를 여러개 만들어서
// 
// WorkQue(std::function<void()> Work)
// 함수 포인터를 넘기면 쓰레드에서 실행된다.
// 
// 보통 코어개수*2+1개 만큼의 쓰레드를 만든다.
// 


// fopen c++ 기반 함수. window가 아닌 Linux에서도 사용 가능

// 소멸자에 virtual...dynamic cast를 사용하기 위해서. 

// 그래픽스와 클라이언트는 엄연히 다른 분야라...디퍼드고 뭐고 관심없다...

// 언리얼도 메인쓰레드는 싱글이다. Tick이 따로 돌지는 않는다.