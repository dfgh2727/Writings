// wrote_250205.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>


// 서버
// 
// IT 기본 지식을 알려줄 뿐 사용하는 것과 전혀 다른 얘기다.
// 
// 서버는 클라이언트와 많은 차이가 있다.
// 서버는 개발 환경이 거의 변하지 않는다. 
// 다양한 경험이 중요하다.
// 
// DB
// 서버를 준비할 시 필수요소.

// 클라이언트와 서버의 책임?
// 
// A와 B의 컴퓨터에서 같은서버에서 게임을 한다고 가정하자.
// B가 명령을 내렸을 때 그 명령을 A에 전달한다. (패킷을 전달한다.) 
// 클라이언트는 '보낸다', '받는다'를 만든다.
// 서버는 '보낸다' 이전과 이후를 담당한다.
// 보통 클라이언트와 서버는 데이터를 한번에 얼마나 보내는지에 대해서 의견이 갈린다.
// 
// 아이템정보와 현금 관련된 정보를 제외하고 클라이언트가 처리한다.
// 클라이언트...메모리에 직접 간섭해서 처리
// 핵이 엄청나게 많이 생기는 이유다.
// 
// 가정용 컴퓨터에서 0.02초가 최고 빠른 전달 속도. 
// FPS에서 총을 쏘고 아무리 빨라도 0.02초 후 모두에게 전달된다.
// 전달된 정보를 변조하는게 핵이다.
// 그러나 서버에서 전달되는 정보를 모두 기록하고 있기 때문에 구분 가능하다.
// 
// 여차저차 충돌 이동 등등은 클라이언트에서 먼저 처리한다.
// 게임마다 차이가 있겠지만 결론적으로 클라이언트가 처리해야 하는 부분이 많다.

// 클라가 신경써야 하는 것: OS, 언어, 유저
// 서버가 신경써야 하는 것: 국제 통신규약, OS, 언어, 유저
//
// Window도 Android도 네이버에 접속 가능하다...왜?
// 기기와 상관없는 규약이 있다.
// (하드웨어 메모리 기본 구조)
// RAM에 있는 특정 바이트를 다른 RAM으로 옮기는 것이 서버.
// 
// packet을 보내면 n바이트가 다른 컴퓨터로 전달될 때
// 전달되는 n 바이트의 구성은 공통적으로 약속되어 있다.
// 그리고 n바이트를 OS가 처리한다.
// 예) n 바이트 중 맨앞의 4바이트는 ip주소, 그 다음 4바이트는 통신 실패 횟수...
// 
// 결론적으로 Window에서 사용하는 통신 처리 방법을 배운다.

//Server
// 
// <WinSock2.h>, <WS2tcpip.h>는 window가 제공하는 서버인터페이스 함수의 헤더. 
// 통신규약인 <WinSock2.h>는 무조건 Windows.h보다 위에 있어야 한다.
#include <WinSock2.h>
#include <Windows.h>
#include <WS2tcpip.h>
// 
// 윈도우에서 통신을 시작하려면 WSAStartup을 무조건 해야 한다.
// 그리고 서버 사용을 위한 라이브러리를 추가해야 한다.
// 
int Port = 30000;
// Port란?
// 서버 프로그램은 외부에서 데이터 받기를 허용한 프로그램을 말한다.
// 이때 내 컴퓨터 밖으로부터 데이터를 받기로 한 프로그램이 하나 뿐인가?
// 카카오톡, 메이플, 던파...
// 외부에서 데이터가 도착했을 때 어디로 가야할까?
// 각 프로그램마다 가지는 포트가 있다. 
// 통신 규약상 데이터를 보낼 때 무조건 port를 지정해줘야 한다.
// 
// 프로그래머들이 피하는 포트가 있다.
// 포트 목록을 확인해보자.
// 
// cmd에 ipconfig를 입력하면 ip주소를 확인할 수 있다.
// 근데 네이버에 내 ip를 검색해서 확인되는 값과 다르다. 
// 네이버를 통해 확인하는 ip -> 통신사 공유기 (글로벌 네트워크에 포함)
// 컴퓨터에서 직접 확인한 게이트 웨이 -> 통신사 공유기 이후의 사제 공유기 (프라이빗 네트워크)
// 
// (게임의 서버는 통신사 공유기의 ip를 인식한다.)
// 
// 통신을 원해도 상대가 다른 프라이빗 네트워크(= 공유기 주소 즉,게이트 웨이가 다름)에 있으면 통신할 수 없다.
// 
// 포트포워딩
// ip 주소가 다른 프라이빗 네트워크에 연결할 수 있게 한다.
// 가령 통신사 공유기가 개인 컴퓨터의 ip로 데이터를 보내게 설정한다.
// 
// ip4와 ip6가 있다.
// 
// inet_pton(AF_INET, "0.0.0.0", &Add.sin_addr)
// 서버는 ip주소를 입력할 필요가 없다.
// ip주소를 Add.sin_addr에 넣어서 복사해준다.
// CPU에 따라 빅에디안, 리틀 에디안이 다르지만
// 리틀, 빅 상관없이 규격에 맞게 리틀에디안으로 변환한다.
// "0.0.0.0"
// 서버는 자신의 ip를 알 필요가 없으므로 위 값을 넣었다.
// 
// 소켓
// 윈도우에서 통신연결에 대한 권한을 가진 핸들.
// 윈도우에서 소켓을 통해 함수를 사용가능하게 한다.
SOCKET AcceptSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
// 
// 바인드는 주소와 소켓을 연결시켜서 이 연결이 어떤 IP주소와 포트로 통신하는지 지정해주는 함수.
// bind(AcceptSocket, (const sockaddr*)&Add, sizeof(SOCKADD_IN))
// ip6를 사용하면 size가 달라질 수 있다.
// 
// 접속 실패시 SOCKET_ERROR
// 
// 서버는 리슨을 호출했을 때 열린다.
// listen(AcceptSocket, BackLog)
// 이때 방화벽에서 서버에 접속 가능허용 여부를 물어본다.
// 방화벽->인바운드 규칙에서 설정을 삭제한 후 재설정할 수 있다.
// 
// 아웃바운드 = 바깥으로 전달한다.
// 
// accept(AcceptSocket,(sockaddr*)&ClinetAdd, &AddressLen )
// 접속자를 직접 처리하겠다는 함수.
// 통신버퍼를 이해해야 할 필요가 있다.
// 참고로 accpet를 기본함수다. wsaaccept와 같은 멀티쓰레드 전용 비동기 접속함수가 있다.
// 100명 이하면 accept로 충분하지만 더 많은 수의 접속자를 처리하기엔 무리다.
// 이때는 wsaaccept와 iocp를 기반한 서버를 공부하면 된다.
// 
// accept를 while문으로 돌려준다.
// accept는 접속자를 백로그 버퍼에서 빼내는 것이다.
// 
// BackLog
// 
// 백로그로 리슨을 호출하는 순간 접속자 버퍼가 생긴다.
// 백로그의 수만큼 접속자 버퍼의 크기가 정해진다.
// 접속자 수 제한이 아니다.
// 
// 서버 프로그램 = (Window에서)listen을 호출하는 프로그램

// Client
// 
// WSAStartup 및 기타등등...은 sever와 같다.
// 단, client는 상대의 IP를 정확하게 알아야 한다.
// 
// 로컬 주소...컴퓨터에 접속함
// 로컬 접속이 제일 빠르다.
// 로컬로 접속이 안 되면 글로벌도 접속이 안 된다.
//
// 클라는 바인드를 할 필요가 없다.
// 커넥트가 내부에서 바인드를 실행해준다.

// 서버는 디버깅 시 '여러 시작 프로젝트'로 
// 클라와 서버를 동시에 확인할 수 있다.

// 게임에서 접속의 시점은 언제일까?
// 아이디와 비밀번호를 입력할 때 이미 접속된 상태다.
// 
// 여러개의 서버를 사용한다.
// [로그인 서버] - [플레이 서버]
// 로그인 서버에서 접속자를 대기시킨다.
// 로그인에 성공하면 플레이 서버에 접속 가능하다.

 SOCKET ClientSocket = accept(AcceptSocket, (sockaddr*)&ClientAdd, &AddressLen);
// accept의 return값은 접속자와의 연결을 의미하는 socket.
// ClientSocket == 접속자
// 
 recv(ClientSocket, &Packet[0], Packet.size(), 0);
// 상대방이 보낸 데이터를 받는다.
// 동기함수다. 즉, 상대방이 패킷을 보낼때까지 대기한다.
// 따라서 멀티쓰레드가 필수다. 그렇지 않으면 recv()에서 멈춰서 무한대기 할 수도 있다.


// OSI7계층과 프로토콜
// 
// 프로토콜:
// 전송되는 데이터(패킷)의 구성에 대한 약속.
// 프로토콜로 패킷에 규격과 규칙을 두어 원활한 통신이 가능하다.
// 상대의 요청을 정확하게 구분할 수 있게하기 위한 서버와 클라이언트간의 약속
// 
// 수업시간에 예로 든 데이터 타입(enum class), 데이터 내용등에 대한 프로토콜은 
// 응용계층의 프로토콜이라 할 수 있다.
// 전송에 필요한 것은 내용뿐 아니라 IP, port도 있다. 전송계층의 프로토콜이다.
// 
// 여차저차 패킷을 보낼때 데이터에 여러가지 정보를 추가한다.
// 
//
//

