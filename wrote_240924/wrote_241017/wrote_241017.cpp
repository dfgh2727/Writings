// wrote_241017.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{

}

//인텔리센스(용어정리)
// ! 반드시 파일은 프로그램(VS, 언리얼 등)에서 지운 뒤 삭제하기 !
// 인텔리센스 기록 초기화, .vs 파일 지우기
// 기록이 너무 많이 쌓이면 VS가 코드가 바뀐걸 빠르게 반영 못할수도 있다.

//Shooting (게임)
//
// 여태 게임에서 Vector 쓴 경우를 생각해보면...
// ConsolEngine.h 에서 class AActor*...AActor를 삭제하진 않는다.
// 근데 슈팅게임에서 총알은? 쓴 총알들을 다 알고 있는건 비효율적이다.
// 
// List를 사용하자!
// 
//  에러가 났는데 뭐가 문제인지 잘 모르겠다? 호출 스택을 뒤로 돌려보자
//  배열 0부터인거 잊지말고.
// 
//  지우는 기능은 프로그램에서 노출시키고 싶어하지 않지만 private으로 할 수도 없다.
//  인터페이스를 만든다. (함수로 따로 만든다.)
// 
//  Tick과 렌더링이 돌아가는게 달라질 수 있기 때문에...
//  tick에서 바로 delete하지 않음
//  
//  Destroy(제거와 같은)와 같은 함수는 최대한 마지막에 호출하는게 좋다.
//  이후에 다른 함수는 호출하지 않는게 좋다.
//  return;
// 
//  vector로 사용해서 필요없는 값의 위치를 nullptr로 만드는건
//  직관적이지 못하고 코드를 더 짜야한다. 빠르다고 해도 별로다.
//


//  벡터가 왜 더 빠를까?
// (배열형이 노드형보다 자료 처리가 빠르다)
//
//  CPU의 처리과정에 대해 대략적인 설명을 해보자면
//  캐쉬, 명령이 대기하는 장소
//  힙에서 필요한 데이터와 기타 데이터를 째로 캐쉬에 가져간다.
//  그리고 필요한 데이터의 위치를 알아낸다. 그리고 메모리가 삭제된다.
//  다시 이 과정을 반복...
// 
//  만약 필요한 데이터들이 연속으로 위치한다면 과정이 훨씬 빨라진다. (캐쉬적중률)
//  따라서 배열이 처리 속도가 훨씬 빠르다.
//  그러나 vector를 사용하고 '중간의 값을 삭제'한다면
//  메모리가 분리되고(메모리 단편화) 적중률이 떨어져 속도가 느려진다. (vector에 구멍이 뚫린다고 표현한다.) 
//  (new도 메모리 단편화 발생, 노드가 느린 이유.)
// 
//  vector를 써서 new와 delete를 반복하면 메모리단편화도 일어나지만
//  할당 가능한 메모리 영역을 찾는데 에너지가 소비된다.
//  
//  AActor는 벡터이니까 메모리친화적인가? 아니다. 
//  각각의 데이터 위치를 알 수 없다. (애시당초 new인걸)
// 
//  ****** 결론: 괜히 속도 조금 올린다고 vector 쓰지 말고 가독성이 높은 List를 쓰자. ******
//

// 이미지도 결국 배열데이터 덩어리다.

// 로직을 한번에 다 짜지 말고 중단점 걸고 한번씩 확인해야 한다.

// switch 지역변수 선언 불가




