// wrote_241010.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
    int Value = 10;

    int ValueAlter = 30;

    int* const ValuePtr0 = &Value;

    *ValuePtr0 = 20; // ValuePtr가 가리키는게 Value라고 고정됨

    *ValuePtr0 = &ValueAlter; //????

 
}


//066_Pure Virtual
//
// 일반 가상함수는 무조건 구현 되어야 한다. 
// 자식이 구현되지 않았을 경우 부모의 함수가 호출되기 때문이다.
// 
// 순수 가상함수는 구현하지 않아도 된다(내용이 없어도 된다). 
// 단 자식이 무조건 구현해야 한다. 부모는 선언만 있는 경우가 있기에. 
// virtual void Init() = 0; (뒤에 = 0을 붙인다)
// void Init () override (자식은 똑같이 오버라이드)
// 순수 가상함수가 있는 클래스를 추상클래스라고 한다.
// 추상클래스는 객체화(구현)가 안 된다.
// 


//067_New (동적 바인딩) 
//new는 연산자로 필요한 때에 필요한 만큼의 메모리를 할당한다.(힙 영역)
// 
// C는 생성자라는 개념이 없다(멤버함수라는 개념이 없으니까). malloc을 쓴 다음 포인터를 할당했다.
//
// new를 쓰면 변수가 사라지지 않는다. 내가 직접 지워야 한다.
// 잘못하면 메모리 동낸다.
// leak은 절대 남겨선 안되고 만든 사람이 없애야 한다.
// 
// 데이터 영역... 외우진 말자 (ppt 참고)
// 코드와 스택영역은 OS가 관리한다.
// 코드는 .exe의 크기. 스택은 
// new만 붙인다고 사용할 수 없다. 메모리가 할당되지만 주소값을 몰라 쓸 수 없다. 
// (new int (); 이렇게만 하면 쓸 수 없다.  
//  int* Ptr = new int(); 요렇게 주소를 알아야 한다.)
// 
// !중요!
// new를 사용한다면 다음 2가지를 세트로 꼭 기억하자...
// 
// 1. leak 체크 (안 쓰이는 동적 할당된 메모리들)
// leak 체크를 명령하는 함수: (헤더 #include <crtdbg.h>) _CrtSetDbgFlag(); (꼭 알고 있자)
// crtdbg가 new를 전역 재정의 한다. 따라서 헤더 중 가장 아래에 둬서 내 것만 영향받게 만들어야 한다.
// 
// 2. leak을 없애기
// int* Ptr = new int();
// delete Ptr;
// 포인터를 이렇게 삭제한다.
// 
// 언리얼이나 기타 엔진은 new를 쓰는 걸 권장하지 않는다.
//
